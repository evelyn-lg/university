#pragma config(Motor,  motorB, Left_Motor, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC, Right_Motor, tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Definir constantes del robot
#define WHEEL_DIAMETER 6.7   // Diámetro de las ruedas en cm (ajustar si es necesario)
#define WHEEL_CIRCUMFERENCE (WHEEL_DIAMETER * 3.1416) // Circunferencia de la rueda
#define ROBOT_WIDTH 13.5    // Distancia entre las ruedas en cm (ajustar según el robot)

// Radio del círculo
#define CIRCLE_RADIUS 10.0   // 1 metro de diámetro => radio de 50 cm
#define CIRCLE_CIRCUMFERENCE (2 * 3.1416 * CIRCLE_RADIUS) // Longitud del círculo en cm

// Cálculo de distancias para las ruedas
#define INNER_RADIUS (CIRCLE_RADIUS - (ROBOT_WIDTH / 2)) // Radio de la rueda interna
#define OUTER_RADIUS (CIRCLE_RADIUS + (ROBOT_WIDTH / 2)) // Radio de la rueda externa

// Distancia que recorrerá cada rueda en el círculo
#define INNER_CIRCUMFERENCE (2 * 3.1416 * INNER_RADIUS)
#define OUTER_CIRCUMFERENCE (2 * 3.1416 * OUTER_RADIUS)

// Relación de velocidades entre la rueda interna y externa
#define INNER_SPEED (50 * (INNER_CIRCUMFERENCE / OUTER_CIRCUMFERENCE))
#define OUTER_SPEED 50  // Fijamos la rueda externa al 50% de potencia

task main() {
    // Reiniciar encoders antes de comenzar
    resetMotorEncoder(Left_Motor);
    resetMotorEncoder(Right_Motor);

    // Recorrer el círculo completo
    while (getMotorEncoder(Left_Motor) < (CIRCLE_CIRCUMFERENCE / WHEEL_CIRCUMFERENCE * 360)) {
        motor[Left_Motor] = INNER_SPEED;  // Velocidad de la rueda interna
        motor[Right_Motor] = OUTER_SPEED;  // Velocidad de la rueda externa
    }

    // Detener el robot al finalizar el círculo
    motor[Left_Motor] = 0;
    motor[Right_Motor] = 0;
}
