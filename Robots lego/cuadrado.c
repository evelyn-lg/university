#pragma config(Motor,  motorB, Left_Motor, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC, Right_Motor, tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Parámetros del robot
#define WHEEL_DIAMETER 6.7    // Diámetro de las ruedas en cm
#define WHEEL_CIRCUMFERENCE (WHEEL_DIAMETER * 3.1416)
#define TRACK_WIDTH 13.5      // Distancia entre ruedas en cm

// Parámetros del símbolo de infinito
#define LOOP_RADIUS 30.0      // Radio de cada lazo en cm
#define SEMICIRCLE_DISTANCE (3.1416 * LOOP_RADIUS)  // Longitud de cada semicírculo en cm

// Radios interno y externo de cada curva
#define INNER_RADIUS (LOOP_RADIUS - (TRACK_WIDTH ))
#define OUTER_RADIUS (LOOP_RADIUS + (TRACK_WIDTH ))

// Distancias recorridas por cada rueda
#define INNER_CIRCUMFERENCE (3.1416 * INNER_RADIUS)
#define OUTER_CIRCUMFERENCE (3.1416 * OUTER_RADIUS)

// Relación de velocidades entre ruedas interna y externa
#define INNER_SPEED (50 * (INNER_CIRCUMFERENCE / OUTER_CIRCUMFERENCE))
#define OUTER_SPEED 30  // La rueda externa se mueve a velocidad base

void traceSemicircle(int direction, bool invertSides) {
    // Reiniciar encoders antes de iniciar la curva
    resetMotorEncoder(Left_Motor);
    resetMotorEncoder(Right_Motor);

    int targetEncoder = SEMICIRCLE_DISTANCE / WHEEL_CIRCUMFERENCE * 360;

    if (invertSides) {
        // Segundo lazo: Cambiamos las ruedas internas y externas
        while (abs(getMotorEncoder(Left_Motor)) < targetEncoder && abs(getMotorEncoder(Right_Motor)) < targetEncoder) {
            motor[Left_Motor] = OUTER_SPEED * direction;
            motor[Right_Motor] = INNER_SPEED * direction;
        }
    } else {
        // Primer lazo: Movemos normal (rueda derecha externa)
        while (abs(getMotorEncoder(Left_Motor)) < targetEncoder && abs(getMotorEncoder(Right_Motor)) < targetEncoder) {
            motor[Left_Motor] = INNER_SPEED * direction;
            motor[Right_Motor] = OUTER_SPEED * direction;
        }
    }

    // Detener el robot al finalizar el semicírculo
    motor[Left_Motor] = 0;
    motor[Right_Motor] = 0;
    wait1Msec(500);
}

task main() {
    traceSemicircle(1, false);  // Primer lazo hacia la derecha
    traceSemicircle(1, true);   // Segundo lazo hacia la izquierda
}
